| 组合                  | 功能                       | 访问公式（实模式下）          |
| ------------------- | ------------------------ | ------------------- |
| **CS : IP**         | 指向下一条指令的位置（程序执行的地方）      | 物理地址 = CS × 16 + IP |
| **SS : SP**         | 指向当前栈顶（函数调用、PUSH/POP 时用） | 物理地址 = SS × 16 + SP |
| **DS : BX/SI/DI/等** | 用于访问数据（变量、数组）            | 物理地址 = DS × 16 + 偏移 |

┌──────────────────────────────┐  ← 高地址（内存尾部）
│        栈段（Stack Segment） │ ← SS:SP 管理
│        函数返回地址、局部变量 │
├──────────────────────────────┤
│        堆（Heap，可选）      │ ← 动态分配
├──────────────────────────────┤
│        数据段（Data Segment）│ ← DS + 偏移 管理
│        全局变量、常量、数组   │
├──────────────────────────────┤
│        代码段（Code Segment）│ ← CS:IP 管理
│        程序指令、函数体       │
└──────────────────────────────┘  ← 低地址（内存起始）

在 x86 16 位寻址模式中，只有以下寄存器可以参与内存间接寻址：
BX、BP、SI、DI
例如mov ax,[bx]

cs:ip 指令 （代码段地址）
[]偏移地址，段地址默认保存ds（数据段）
立即数通过通用寄存器保存到段寄存器
ss:sp 栈顶


xx segment段开始
xx ends段结束   （end segment）
成对使用

end 结束

mov ax, 4C00h
int 21h
MS-DOS 程序退出的标准写法


loop 标号
（cx）-=1
cx为0跳转标号，为0向下执行
s： mov ax，ax
loop s
双循化嵌套用寄存器保存cx的数值内循环每次结束恢复 或者用内存单元来保存 或者用栈保存
段转移

字=2字节


段寄存器不能直接参与普通的 MOV 数据传送到通用寄存器中。
mov al, ds:[0]
mov al, [0]
mov al, ds（错误的）
段寄存器不能直接通过内存操作加载或存储，只能通过通用寄存器中转。



内存地址偏移量
| 可用寄存器 | 说明            |
| ----- | ------------- |
| BX    | 基址寄存器，默认 DS 段 |
| BP    | 基址寄存器，默认 SS 段 |
| SI    | 源索引，默认 DS 段   |
| DI    | 目的索引，默认 DS 段  |

idate常量
[bx] 内存单元 偏地址在bx里面
[bx+idate]更加灵活i表示   =  idate[bx]

[bx+si]    =    [bx][si]
[bx+200+si]    =    [bx][si].200    =    [bx].200[si]     200为idate
一般有idate一个常量地址，一个寄存器一个变量地址  eg：[bx].200[si] 一个常量加上两个变量

默认段地址在ss中
[]中只能有bx和si bx和di bp和si bp和di的组合一起出现，不能有其他组合，idate都可以加或者这几个单独出现
前面基址是ds                后面是ss，就只有bp段基址是ss






| 指令            | 类型        | 含义                                       | 数据来源    |
| ------------- | --------- | ---------------------------------------- | ------- |
| `mov ax, 0`   | **立即数寻址** | 把常数 `0` 直接送进寄存器 AX                       | 立即数（常量） |
| `mov ax, [0]` | **内存寻址**  | 从内存中 **地址 = DS:0000h** 的地方取出 2 个字节，送进 AX | 内存      |

| 指令   | 全称                | 数据大小       | 举例                 | 说明                   |
| ---- | ----------------- | ---------- | ------------------ | -------------------- |
| `db` | Define Byte       | 1 字节       | `num db 5`         | 在内存中分配 1 字节，值为 5     |
| `dw` | Define Word       | 2 字节（16 位） | `num dw 1234h`     | 在内存中分配 2 字节，值为 1234h |
| `dd` | Define Doubleword | 4 字节       | `num dd 12345678h` | 在内存中分配 4 字节          |

reg通用寄存器    sreg段寄存器

div除法指令
| 操作数大小              | 寄存器组合                    | 商存放        | 余数存放 |
| ------------------ | ------------------------ | ---------- | ---- |
| 8 位 (`div r/m8`)   | AL / [mem8]              | AL         | AH   |
| 16 位 (`div r/m16`) | AX / [mem16] → 除数 r/m16  | AX / DX:AX | DX   |
| 32 位 (`div r/m32`) | EAX / [mem32] → 除数 r/m32 | EAX        | EDX  |
div reg（保存除数的）或者div 内存单元


dup
db 3 dup （0）定义三个一个字节的0
db 3 dup （1,2）    =    db 1,2,1,2,1,2



jmp ax   修改ip 段内转移
jmp 1000：0   修改ip和cs 段间转移
jmp short s（跳转到s最多跳转-128-127个字节  ）
jmp near s（跳转到s最多跳转-32768-32767个字节  ）
jmp far s 远转移
jmp word ptr 内存单元地址，  在这个内存单元地址读取一个字作为偏移地址


offset 标号  获取标号的偏移地址


jcxz有条件转移指令，是短转移，cx=0跳转到标号执行，ip=ip+8位位移

ret修改ip 近转移
IP = [SP]        ; 从栈顶弹出 IP
SP = SP + 2      ; 栈指针上移 2 字节

retf修改cs和ip 远转移
IP = [SP]        ; 弹出 IP
SP = SP + 2
CS = [SP]        ; 弹出 CS
SP = SP + 2
ret / retf 的本质就是 把调用地址从栈中取出，让 CPU 跳回调用处继续执行
实模式下栈是16位为单位操作的

call将当前ip或者ip和cs压栈中，然后转移，注意不能实现短转移
call 标号 相当于 push IP     jmp naer ptr 标号

mul乘法
| 操作数类型 | 隐含寄存器       | 结果存放位置  |
| ----- | ----------- | ------- |
| 8位    | AL × r/m8   | AX      |
| 16位   | AX × r/m16  | DX:AX   |
| 32位   | EAX × r/m32 | EDX:EAX |
| 64位   | RAX × r/m64 | RDX:RAX |
8位乘法保存在AX中，16位高位DX低位AX
乘数保存AL              AX    

标志寄存器
zf 零标志位   为0zf等于1  否则0
bf 奇偶标志位  bit位为1个数为偶数 pf=1否则0
sf 负数 sf=1 否则0
略.....看下表

|  位号（从低到高） |   名称   | 中文名                           | 含义 / 作用                                                |
| :-------: | :----: | :---------------------------- | :----------------------------------------------------- |
|   **0**   | **CF** | Carry Flag（进位标志）              | 算术运算产生进位或借位时，CF = 1，否则 0。用于无符号数判断。                     |
|   **1**   |  **—** | 保留（未使用）                       | 固定为 1 或未定义。                                            |
|   **2**   | **PF** | Parity Flag（奇偶标志）             | 结果的最低 8 位中，**1 的个数为偶数** → PF = 1，否则 PF = 0。            |
|   **3**   |  **—** | 保留                            |                                                        |
|   **4**   | **AF** | Auxiliary Carry（辅助进位标志）       | 第 3 位（低半字节）向第 4 位产生进位/借位。用于 BCD（二进制编码十进制）运算。           |
|   **5**   |  **—** | 保留                            |                                                        |
|   **6**   | **ZF** | Zero Flag（零标志）                | 运算结果为 0 → ZF = 1，否则 0。                                 |
|   **7**   | **SF** | Sign Flag（符号标志）               | 运算结果的最高位（符号位）为 1 → SF = 1（结果为负），否则 0。                  |
|   **8**   | **TF** | Trap Flag（陷阱标志）               | 设为 1 时，CPU 进入**单步执行模式**（调试用）。                          |
|   **9**   | **IF** | Interrupt Enable Flag（中断允许标志） | IF = 1 → 允许可屏蔽中断；IF = 0 → 禁止可屏蔽中断。                     |
|   **10**  | **DF** | Direction Flag（方向标志）          | 控制串操作：DF = 0 → SI/DI 自增（从低到高）；DF = 1 → SI/DI 自减（从高到低）。 |
|   **11**  | **OF** | Overflow Flag（溢出标志）           | 有符号运算结果溢出（符号位错误）→ OF = 1，否则 0。                         |
| **12–15** |  **—** | 保留 / 未定义                      | 8086 未使用，高位在后续处理器扩展。                                   |

adc带进位加法指令
adc ax，bx     （ax）=（ax）+（bx）+CF
就是(AX:BX) + (CX:DX)
我将低位如果溢出那么高位就会加上cf的1,然后重置cf
| 场景    | 指令    | 是否考虑 CF  | 用途         |
| ----- | ----- | -------- | ---------- |
| 普通加法  | `ADD` | ❌ 不考虑 CF | 单字节或单寄存器加法 |
| 带进位加法 | `ADC` | ✅ 加上 CF  | 多字节加法      |
| 普通减法  | `SUB` | ❌ 不考虑 CF | 单次减法       |
| 带借位减法 | `SBB` | ✅ 减去 CF  | 多字节减法      |

cmp 仅仅重置标志位寄存器，不做减法操作

| 指令                  | 含义                                | 判断条件（FLAGS）    | 常见场景       |
| ------------------- | --------------------------------- | -------------- | ---------- |
| **JE / JZ**         | Jump if Equal / Zero              | ZF = 1         | 比较结果相等时跳转  |
| **JNE / JNZ**       | Jump if Not Equal / Not Zero      | ZF = 0         | 比较结果不相等时跳转 |
| **JG / JNLE**       | Jump if Greater                   | ZF = 0 且 SF=OF | 有符号大于      |
| **JL / JNGE**       | Jump if Less                      | SF ≠ OF        | 有符号小于      |
| **JGE / JNL**       | Jump if Greater or Equal          | SF = OF        | 有符号大于等于    |
| **JLE / JNG**       | Jump if Less or Equal             | ZF=1 或 SF≠OF   | 有符号小于等于    |
| **JA / JNBE**       | Jump if Above                     | CF=0 且 ZF=0    | 无符号大于      |
| **JB / JC / JNAE**  | Jump if Below / Carry             | CF=1           | 无符号小于      |
| **JAE / JNB / JNC** | Jump if Above or Equal / No Carry | CF=0           | 无符号大于等于    |
| **JBE / JNA**       | Jump if Below or Equal            | CF=1 或 ZF=1    | 无符号小于等于    |

通过cmp ax，bx再使用跳转指令可以用来判断ax和bx中的数值是否相等

rep movsb   ==   s：movsb      loop s
| 指令    | 操作单位 | 实际读取寄存器        | 实际写入寄存器        | 每次移动 | 自动加减 |
| ----- | ---- | -------------- | -------------- | ---- | ---- |
| MOVSB | 字节   | AL ← [DS:SI]   | [ES:DI] ← AL   | 1 字节 | ±1   |
| MOVSW | 字    | AX ← [DS:SI]   | [ES:DI] ← AX   | 2 字节 | ±2   |
| MOVSD | 双字   | EAX ← [DS:ESI] | [ES:EDI] ← EAX | 4 字节 | ±4   |

movsb  ==  (es)*16+(di)=(ds)*16+(si)    df=0   (si)+=1  (di)+=1   
df=1   (si)-=1   (di)-=1
就是将数据传输

| 指令              | 全称             | 压入的内容               | 操作对象          |
| --------------- | -------------- | ------------------- | ------------- |
| **PUSH 寄存器/内存** | Push (value)   | 压入某个寄存器或内存单元的值      | 通用寄存器或立即数     |
| **PUSHF**       | Push **Flags** | 压入 **FLAGS 寄存器的内容** | **CPU 标志寄存器** |
| 指令             | 全称            | 弹出的目标            | 修改对象                  |
| -------------- | ------------- | ---------------- | --------------------- |
| **POP 寄存器/内存** | Pop (value)   | 从栈弹出 → 通用寄存器     | AX、BX、SI、DI 等         |
| **POPF**       | Pop **Flags** | 从栈弹出 → FLAGS 寄存器 | 恢复标志位（ZF、SF、CF、OF...） |
| 对比   | 无 F（PUSH/POP） | 有 F（PUSHF/POPF） |
| ---- | ------------- | --------------- |
| 操作对象 | 通用寄存器或内存      | FLAGS 寄存器       |
| 典型用途 | 保存变量或参数       | 保存/恢复 CPU 状态    |
| 栈内容  | 数据值           | 标志寄存器状态         |
| 影响标志 | 不改变标志         | POPF 会修改标志      |




| 分类       | 来源          | 示例        | 触发方式  |
| -------- | ----------- | --------- | ----- |
| **外中断**  | 硬件信号        | 键盘、定时器    | 外部触发  |
| **内中断**  | CPU 内部检测    | 除零、溢出、单步  | 自动触发  |
| **软件中断** | 程序执行 INT 指令 | `INT 21h` | 程序员触发 |

| 操作阶段   | 动作                 | 指令     |
| ------ | ------------------ | ------ |
| 进入中断   | 压 FLAGS、CS、IP，清 IF | 自动完成   |
| 执行中断程序 | 响应对应 ISR           | 程序员编写  |
| 退出中断   | 弹 IP、CS、FLAGS      | `IRET` |


| 指令       | 弹出内容                  | 用途           |
| -------- | --------------------- | ------------ |
| **RET**  | 只弹出 IP（或 IP+CS，用于远返回） | 子程序返回        |
| **IRET** | 弹出 IP、CS、FLAGS        | 中断返回（需要恢复标志） |
iret用于中断的返回

执行 CLI 后，CPU 暂时不会响应来自外设的 可屏蔽中断；
只有执行 STI 后，CPU 才会再次响应。
CLI    ; 禁止中断，保护临界区
...
STI    ; 恢复中断响应
来执行原子操作


| 指令  | 含义 | 类似运算 | 空位补什么 | 进位标志（CF） |
| --- | -- | ---- | ----- | -------- |
| SHL | 左移 | ×2   | 右边补 0 | 保存溢出位    |
| SHR | 右移 | ÷2   | 左边补 0 | 保存移出的位   |
移动大于1将位数放到cl



INT n  软件中断 跳转到中断向量表中编号为 n 的中断服务程序执行

in out 操作端口   只能用al和ax      访问8/16端口


内中断
| 步骤  | 操作                       | 说明                                             |
| --- | ------------------------ | ---------------------------------------------- |
| 1️⃣ | 从指令流中取出中断号 **n**         | 如果是 INT 指令，CPU 从操作码中得到 n；<br>如果是异常，则由硬件逻辑生成 n。 |
| 2️⃣ | **将 FLAGS 寄存器压入栈**       | 保存当前状态标志（如 IF、TF、ZF 等），以便中断返回时恢复。              |
| 3️⃣ | **清除 IF 和 TF 标志**        | 关闭中断与单步，防止中断嵌套或调试干，==0扰。                           |
| 4️⃣ | **将当前 CS 压入栈**           | 保存当前代码段寄存器。                                    |
| 5️⃣ | **将当前 IP 压入栈**           | 保存下一条将要执行的指令地址（中断返回时要用）。                       |
| 6️⃣ | **从中断向量表取出 n 对应的 CS:IP** | 从内存地址 `n * 4`（IP） 和 `n * 4 + 2`（CS）读取新的目标地址。   |
| 7️⃣ | **加载新的 CS 和 IP**         | 跳转到中断服务程序（ISR）的入口处开始执行。                        |

可屏蔽中断 来自cpu外部，if=1则不中断
 sti 设置if=1         cli  设置if=0

| 方式            | 是否显式标签 | 适用场景   | 注意事项                      |
| ------------- | ------ | ------ | ------------------------- |
| `a db 1,2,3`  | 隐式     | 简短数据定义 | 可用，但在大段代码中可能不够直观          |
| `a: db 1,2,3` | 显式     | 推荐     | 清晰标明 `a` 是标签，尤其是和指令混合时更安全 有：只能在代码段使用|

seg x  获得x的段地址





