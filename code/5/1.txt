; loader.S - 内存检测并保存 total_mem_bytes
; 参考：project/c5/a/boot/loader.S
; 汇编器：NASM 风格
;
bits 16
org 0x900             ; loader.bin 的加载地址（你项目中设定的地址）

%include "boot.inc"   ; 包含项目共有宏/常量定义 (比如 LOADER_BASE_ADDR, GDT_BASE, GDT_LIMIT 等)

section loader vstart=LOADER_BASE_ADDR

; ----------------------------
; 常量与等号定义（示例，替换为你的 boot.inc/项目中定义）
; ----------------------------
LOADER_BASE_ADDR    equ 0x900
LOADER_STACK_TOP    equ LOADER_BASE_ADDR    ; 按你的片段，stack top equ base

; ----------------------------
; GDT 等（此处按你的原文：定义 GDT，未有新变化）
; 你应将实际的 GDT descriptor 内容放到下面。
; 这里为示例占位，实际请用项目中真实 GDT 描述符替换
; ----------------------------
gdt_start:
    ; 示例 GDT（NULL, CODE, DATA 等） - 8 字节/描述符
    dq 0x0000000000000000    ; NULL
    dq 0x00CF9A000000FFFF    ; Code segment (示例值，请用你真实的描述符)
    dq 0x00CF92000000FFFF    ; Data segment (示例值)
GDT_END:

; 占位填充至某长度（保证对齐/空间）
times 60 dq 0

; ----------------------------
; total_mem_bytes 存放位置（占 4 字节）
; 说明：文件头 0x200，加载地址 0x900 -> total_mem_bytes 在内存地址 0xb00
; ----------------------------
total_mem_bytes:    dd 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GDT 指针（limit(2) + base(4)）
gdt_ptr:
    dw GDT_END - gdt_start - 1   ; GDT_LIMIT
    dd gdt_start                  ; GDT_BASE

; 人工对齐： total_mem_bytes(4) + gdt_ptr(6) + ards_buf(244) + ards_nr(2) = 256 字节
ards_buf:    times 244 db 0
ards_nr:     dw 0   ; 用于记录 ARDS 结构体数量

; ----------------------------
; loader 起始
; ----------------------------
loader_start:

    ; 初始化寄存器
    xor ax, ax
    mov ss, ax
    mov sp, LOADER_STACK_TOP     ; 设置栈（根据你的段/模式，或用默认）
    ; 如果需要设置 ds/es 等，请在 boot.inc 里按你的环境设置

    ; ----------------------------
    ; 使用 INT 15h, AX=E820h 获取内存地图（SMAP）
    ; ----------------------------
    xor ebx, ebx                 ; EBX = 0 : 第一次调用时需要为 0 (continuation)
    mov edx, 0x534D4150          ; 'SMAP' 标识
    mov di, ards_buf             ; DI 指向 ards_buf (16-bit 寄存器作为 offset)
.e820_mem_get_loop:
    mov eax, 0x0000E820
    mov ecx, 20                  ; 每个 ARDS 描述符 20 字节
    push ds
    ; 确保 ES:DI 指向缓冲区 (这里假设 ds == es)
    ; 若需要切换 ES，请在此设置： mov ax, seg ards_buf; mov es, ax; mov di, offset ards_buf
    int 0x15
    pop ds
    jc .e820_failed_so_try_e801  ; CF=1 表示调用失败 -> 尝试 E801
    ; 若成功，BIOS 会把一块描述符写到 ES:DI（20字节）
    add di, cx                   ; DI += 20, 指向下一个缓冲区位置
    inc word [ards_nr]           ; 记录 ARDS 数量（16-bit）
    cmp ebx, 0
    jnz .e820_mem_get_loop       ; EBX != 0 表示还有更多条目，继续循环

    ; 如果走到这里，说明所有 ARDS 都返回完毕
    jmp .find_max_mem_area

; ----------------------------
; 若 E820 失败，尝试 E801
; ----------------------------
.e820_failed_so_try_e801:
    mov ax, 0xE801
    int 0x15
    jc .e801_failed_so_try88     ; 若 E801 也失败，转到 0x88
    ; E801 返回的格式比较特殊：
    ; AX/CX = 低 1MB~16MB 的数（单位 KB）
    ; BX/DX = 16MB 以上的数（单位 64KB）
    ; 我们要把它们合并成字节数（32-bit），并且补回低端 1MB

    ; 先把 AX (KB 单位) 转为字节，并放到 ESI 做临时保存
    mov cx, 0x400                ; 1024
    mul cx                       ; EAX = AX * 1024 (注意：这里 mul 作用于 AX; 在 16-bit 环境需要注意)
    ; 为了使用 32-bit 操作，直接用 EAX = AX * 1024 更稳妥（NASM 在 16-bit 模式仍可）
    ; 此处假定低位结果在 EAX
    ; 将结果放入 ESI（备份低 15MB 部分）
    mov esi, eax

    ; 将高段 BX（单位 64KB）转换为字节再加入
    xor eax, eax
    mov ax, bx                   ; ax = bx (16-bit) -> 低 16 位
    mov ecx, 0x10000             ; 64KB
    mul ecx                      ; EDX:EAX = AX * 0x10000  (AX 16bit * ECX 32bit 在 NASM 会扩展)
    add esi, eax                 ; esi = lower-part + upper-part (字节为单位)

    ; E801 给出的值不含低端的 1MB（BIOS 占用区），因此需要补回 1MB
    add esi, 0x00100000

    mov edx, esi                 ; edx = total bytes
    jmp .mem_get_ok

; ----------------------------
; 若 E801 失败，尝试 AH=0x88
; ----------------------------
.e801_failed_so_try88:
    mov ah, 0x88
    int 0x15
    jc .error_hlt                ; 若 0x88 也失败 -> 错误
    ; 返回时，AX = 以 KB 为单位的内存大小（不包括低 1MB）
    and eax, 0x0000FFFF
    mov cx, 0x400                ; 1024
    mul cx                       ; EAX = AX * 1024 (bytes)
    ; 将 16-bit * 16-bit 放入 EAX (NASM 在 16-bit 模式处理)
    ; 把结果（EAX）扩展到 EDX:EAX 的形式，最终把它合并到 EDX
    shl edx, 16                  ; 把 DX 移到高 16 位 (兼容上面注释)
    or edx, eax                  ; edx = 32-bit bytes  (注意：此处仅为实现逻辑）
    add edx, 0x00100000          ; 0x88 只返回 1MB 以上，需要补回 1MB
    jmp .mem_get_ok

; ----------------------------
; 遍历 ARDS，找出最大的 (base_low + length_low)
; ----------------------------
.find_max_mem_area:
    mov cx, [ards_nr]            ; ARDS 数量
    cmp cx, 0
    je .mem_get_ok_if_none       ; 如果没有 ARDS 条目，跳过
    mov ebx, ards_buf            ; EBX 指向 ARDS 缓冲区（使用 32-bit 地址）
    xor edx, edx                 ; EDX 保存最大值 (32-bit)
.find_max_mem_area_loop:
    ; 每个 ARDS: 0: base_low (4) | 4: base_high (4) | 8: length_low (4) | 12: length_high (4) | 16: type (4)
    mov eax, [ebx]               ; base_low
    add eax, [ebx+8]             ; base_low + length_low
    add ebx, 20                  ; 下一个 ARDS（20 bytes）
    cmp edx, eax
    jge .next_ards_noupdate
    mov edx, eax                 ; edx = new max
.next_ards_noupdate:
    loop .find_max_mem_area_loop

    ; edx 即为最大 base_low + length_low
    jmp .mem_get_ok

.mem_get_ok_if_none:
    ; 如果没有 ARDS（非常罕见），可以尝试别的策略（这里简单置 0）
    xor edx, edx
    jmp .mem_get_ok

.mem_get_ok:
    ; 将结果（EDX）写入 total_mem_bytes
    mov [total_mem_bytes], edx

    ; 到此内存检测完成，继续 loader 的余下工作（比如切换到保护模式、加载内核等）
    ; 下面用一个简单的无限循环占位（请替换为你的后续代码）
    cli
.hang:
    hlt
    jmp .hang

.error_hlt:
    ; 内存检测全部失败，直接停止（实际可替换为错误提示）
    cli
    hlt
    jmp .hang

; ----------------------------
; 填充/对齐（如有需要）
; ----------------------------
times 512 - ($ - $$) db 0   ; 将 loader 填充到 512 字节（示例：若需做引导扇区），可按需修改
